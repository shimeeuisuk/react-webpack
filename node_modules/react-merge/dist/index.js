"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeState = exports.merge = void 0;
const is_fns_1 = require("is-fns");
const objects_fns_1 = require("objects-fns");
function mergeState(state, source, options = {}) {
    const fn = options.noSymbol ? objects_fns_1.objKeys : objects_fns_1.objKeysNSymb;
    let { delSymbol, del, diff, replace, arrays, path } = options;
    if (path) {
        if (is_fns_1.isString(path))
            path = path.split('/');
        source = objects_fns_1.setIn({}, source, path);
        if (replace && !is_fns_1.isFunction(replace))
            replace = objects_fns_1.setIn({}, replace, path);
    }
    let forceReplace = replace;
    if (typeof forceReplace !== 'function') {
        if (!is_fns_1.isMergeable(replace))
            forceReplace = () => false;
        else
            forceReplace = (path) => objects_fns_1.getIn(replace, path);
    }
    if (replace === true || forceReplace([], state, source) === true)
        return { state: source, changes: state !== source ? source : undefined };
    if (!is_fns_1.isFunction(arrays))
        arrays = undefined;
    function recusion(state, source, track = []) {
        const changes = {};
        const isSourceArray = is_fns_1.isArray(source);
        if (!is_fns_1.isMergeable(state)) {
            state = isSourceArray ? [] : {}; // return only elements
            if (is_fns_1.isArray(state))
                changes.length = 0;
        }
        const isStateArray = is_fns_1.isArray(state);
        if (!is_fns_1.isMergeable(source))
            return { state }; // merge only mergeable elements, may be throw here
        if (isStateArray && isSourceArray) {
            if (arrays)
                source = arrays(track, state, source);
            if (state.length != source.length)
                changes.length = source.length;
        }
        let stateKeys = fn(state);
        if (stateKeys.length == 0 && !del) {
            if (!isStateArray && !isSourceArray)
                return fn(source).length ? { state: source, changes: source } : { state };
            if (isStateArray && isSourceArray) {
                if (state.length == source.length && source.length == 0)
                    return { state };
                return (fn(source).length || source.length !== state.length) ? { state: source, changes: source } : { state };
            }
        }
        let srcKeys = fn(source);
        const changedObjects = {};
        const result = (isStateArray ? [] : {});
        if (diff) {
            stateKeys.forEach(key => {
                if (!~srcKeys.indexOf(key))
                    changes[key] = delSymbol;
            });
        }
        srcKeys.forEach(key => {
            if (del && source[key] === delSymbol) {
                if (state.hasOwnProperty(key))
                    changes[key] = delSymbol;
            }
            else {
                let keyTrack = track.concat(key);
                if (!is_fns_1.isMergeable(source[key]) || !is_fns_1.isMergeable(state[key]) || forceReplace(keyTrack, state[key], source[key]) === true) {
                    if (!state.hasOwnProperty(key) || !is_fns_1.is(state[key], source[key]))
                        changes[key] = source[key];
                }
                else {
                    if (state[key] !== source[key]) {
                        let obj = recusion(state[key], source[key], keyTrack);
                        if (obj.changes)
                            changedObjects[key] = obj;
                    }
                }
            }
        });
        let changedObjKeys = fn(changedObjects);
        let changesKeys = fn(changes);
        if (changesKeys.length == 0 && changedObjKeys.length == 0)
            return { state };
        else {
            Object.assign(result, state);
            changesKeys.forEach(key => {
                if (del && changes[key] === delSymbol || diff && !source.hasOwnProperty(key))
                    delete result[key];
                else
                    result[key] = changes[key];
            });
            changedObjKeys.forEach(key => {
                result[key] = changedObjects[key].state;
                changes[key] = changedObjects[key].changes;
            });
            return { state: result, changes };
        }
    }
    return recusion(state, source);
}
exports.mergeState = mergeState;
const merge = (a, b, opts = {}) => mergeState(a, b, opts).state;
exports.merge = merge;
merge.all = function (state, obj2merge, options = {}) {
    if (obj2merge.length == 0)
        return state; // no changes should be done
    else
        return obj2merge.reduce((prev, next) => merge(prev, next, options), state); // merge
};
//# sourceMappingURL=index.js.map