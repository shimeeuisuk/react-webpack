"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.intoArray = exports.moveArrayElems = exports.push2array = exports.resolvePath = exports.string2path = exports.setIn = exports.hasIn = exports.getIn = exports.objKeysNSymb = exports.objKeys = exports.objMap = exports.splitBy$ = exports.objSplit = void 0;
const isArray = Array.isArray;
const isUndefined = (value) => typeof value === 'undefined';
function isMergeable(val) {
    const nonNullObject = val && typeof val === 'object';
    return nonNullObject
        && Object.prototype.toString.call(val) !== '[object RegExp]'
        && Object.prototype.toString.call(val) !== '[object Date]';
}
const objKeys = Object.keys;
exports.objKeys = objKeys;
const objKeysNSymb = (obj) => objKeys(obj).concat(Object.getOwnPropertySymbols(obj));
exports.objKeysNSymb = objKeysNSymb;
const objMap = (object, fn, track = []) => objKeys(object).reduce((result, key) => ((result[key] = fn(object[key], track.concat(key))) || true) && result, isArray(object) ? [] : {});
exports.objMap = objMap;
function objSplit(obj, fn, byKey = false) {
    let res = [];
    objKeys(obj).forEach((key) => setIn(res, obj[key], fn(byKey ? key : obj[key]), key));
    return res;
}
exports.objSplit = objSplit;
function splitBy$(obj) {
    return objSplit(obj, (k) => k[0] === '$' ? 0 : 1, true);
}
exports.splitBy$ = splitBy$;
//////////////////////////////
//  object get/set functions
/////////////////////////////
function getIn(state, ...paths) {
    let res = state;
    for (let i = 0; i < paths.length; i++) {
        let track = paths[i];
        if (typeof track === 'function')
            track = track(res);
        if (!isArray(track))
            track = [track];
        for (let j = 0; j < track.length; j++) {
            if (!isMergeable(res))
                return undefined;
            if (isUndefined(track[j]))
                continue;
            res = res[track[j]];
        }
    }
    return res;
}
exports.getIn = getIn;
function hasIn(state, ...paths) {
    if (paths.length > 0) {
        for (let i = 0; i < paths.length; i++) {
            let path = isArray(paths[i]) ? paths[i] : [paths[i]];
            for (let j = 0; j < path.length; j++) {
                if (isUndefined(path[j]))
                    continue;
                try {
                    if (!state.hasOwnProperty(path[j]))
                        return false;
                }
                catch (e) {
                    return false;
                }
                state = state[path[j]];
            }
        }
    }
    return true;
}
exports.hasIn = hasIn;
function setIn(state, value, ...paths) {
    let result = state;
    let key;
    if (paths.length > 0) {
        for (let i = 0; i < paths.length; i++) {
            let path = isArray(paths[i]) ? paths[i] : [paths[i]];
            for (let j = 0; j < path.length; j++) {
                if (isUndefined(path[j]))
                    continue;
                if (!isUndefined(key)) {
                    if (!isMergeable(result[key]))
                        result[key] = {};
                    result = result[key];
                }
                key = path[j];
                // prev = result;
                // result = result[key];
            }
        }
    }
    if (!isUndefined(key))
        result[key] = value;
    else
        return value;
    return state;
}
exports.setIn = setIn;
// function delIn(state: any, path: any[]) {
//   // if (path[0] == '#') path = path.slice(1);
//   if (!path.length) return state;
//   const keys = typeof path[0] == 'string' ? path[0].split(',') : [path[0]];
//   const newPath = path.slice(1);
//   if (newPath.length) {
//     keys.forEach((key: any) => {
//       let newObj;
//       if (isMergeable(state[key])) newObj = delIn(state[key], newPath);
//       if (newObj && (newObj !== state[key])) state = merge(state, {[key]: newObj}, {replace: {[key]: true}})
//     })
//   } else {
//     for (let i = 0; i < keys.length; i++) {
//       if (state.hasOwnProperty(keys[i])) {
//         state = Object.assign({}, state);
//         break
//       }
//     }
//     for (let i = 0; i < keys.length; i++) delete state[keys[i]]
//   }
//   return state
// }
function string2path(path, { str2sym, replace } = {}) {
    // path = path.replace(symConv(SymData), '/' + symConv(SymData) + '/');
    if (replace)
        path = replace(path);
    path = path.replace(/\/+/g, '/');
    const result = [];
    path.split('/').forEach(key => key && (key = (str2sym ? str2sym(key.trim()) : key.trim())) && result.push(key));
    return result;
}
exports.string2path = string2path;
function resolvePath(path, base) {
    const result = (base && (path[0] === '.' || path[0] == '..')) ? base.slice() : [];
    for (let i = 0; i < path.length; i++) {
        let val = path[i];
        if (val === '..')
            result.pop();
        else if (val !== '' && val !== '.')
            result.push(val);
    }
    return result;
}
exports.resolvePath = resolvePath;
/// Array
function push2array(array, ...vals) {
    for (let i = 0; i < vals.length; i++) {
        if (isArray(vals[i]))
            array.push(...vals[i]);
        else
            array.push(vals[i]);
    }
    return array;
}
exports.push2array = push2array;
function moveArrayElems(arr, from, to) {
    let length = arr.length;
    if (length) {
        from = (from % length + length) % length;
        to = (to % length + length) % length;
    }
    let elem = arr[from];
    for (let i = from; i < to; i++)
        arr[i] = arr[i + 1];
    for (let i = from; i > to; i--)
        arr[i] = arr[i - 1];
    arr[to] = elem;
    return arr;
}
exports.moveArrayElems = moveArrayElems;
const intoArray = (value) => isArray(value) ? value : [value];
exports.intoArray = intoArray;
//# sourceMappingURL=index.js.map