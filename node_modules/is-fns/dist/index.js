"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isPromise = exports.isFunction = exports.isEmpty = exports.isArray = exports.isPlainObject = exports.isObject = exports.isString = exports.isInteger = exports.isNumber = exports.isUndefined = exports.isNull = exports.isBool = exports.isMergeable = exports.isEqual = exports.is = void 0;
const isNull = (value) => value === null;
exports.isNull = isNull;
const isUndefined = (value) => typeof value === 'undefined';
exports.isUndefined = isUndefined;
const isNumber = (value) => typeof value === "number";
exports.isNumber = isNumber;
const isInteger = (value) => typeof value === "number" && (Math.floor(value) === value || value > 9007199254740992 || value < -9007199254740992);
exports.isInteger = isInteger;
const isString = (value) => typeof value === 'string';
exports.isString = isString;
const isBool = (value) => value === false || value === true;
exports.isBool = isBool;
const isEmpty = (value) => isMergeable(value) && Object.keys(value).length === 0;
exports.isEmpty = isEmpty;
const isObject = (value) => isMergeable(value) && !isArray(value);
exports.isObject = isObject;
const isArray = Array.isArray;
exports.isArray = isArray;
const isFunction = (value) => typeof value === 'function';
exports.isFunction = isFunction;
const isPromise = (value) => isFunction(value === null || value === void 0 ? void 0 : value.then);
exports.isPromise = isPromise;
const isPlainObject = (value) => isObject(value) && value.constructor === Object;
exports.isPlainObject = isPlainObject;
const _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
    ? (obj) => typeof obj
    : (obj) => obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
function isMergeable(val) {
    const nonNullObject = val && typeof val === 'object';
    return nonNullObject
        && Object.prototype.toString.call(val) !== '[object RegExp]'
        && Object.prototype.toString.call(val) !== '[object Date]';
}
exports.isMergeable = isMergeable;
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
function is(x, y) {
    // SameValue algorithm
    if (x === y) { // Steps 1-5, 7-10
        // Steps 6.b-6.e: +0 != -0
        return x !== 0 || 1 / x === 1 / y;
    }
    else {
        // Step 6.a: NaN == NaN
        return x !== x && y !== y;
    }
}
exports.is = is;
function isEqual(objA, objB, options = {}) {
    if (is(objA, objB))
        return true;
    if ((isUndefined(objA) ? 'undefined' : _typeof(objA)) !== 'object' || objA === null || (isUndefined(objB) ? 'undefined' : _typeof(objB)) !== 'object' || objB === null)
        return false;
    const fn = options.symbol ? (obj) => Object.keys(obj).concat(Object.getOwnPropertySymbols(obj)) : Object.keys;
    const keysA = fn(objA);
    const keysB = fn(objB);
    if (keysA.length !== keysB.length)
        return false;
    const { skipKeys = [], deepKeys = [] } = options;
    for (let i = 0; i < keysA.length; i++) {
        if (~skipKeys.indexOf(keysA[i]))
            continue; // if key is an skip key, skip comparison
        if (options.deep || ~deepKeys.indexOf(keysA[i])) {
            const result = isEqual(objA[keysA[i]], objB[keysA[i]], options);
            if (!result)
                return false;
        }
        else if (!objB.hasOwnProperty(keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
            return false;
        }
    }
    return true;
}
exports.isEqual = isEqual;
//# sourceMappingURL=index.js.map